<?php
/**
 * Functions
 */

$protocol = ( (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') || $_SERVER['SERVER_PORT'] == 443 ) ? 'https://' : 'http://';

$GLOBALS['bloginfo']['name'] = 'Static Nebula';
$GLOBALS['bloginfo']['home_url'] = 'http://gearside.com/nebula/Static-Nebula-master';
$GLOBALS['bloginfo']['template_directory'] = rtrim($protocol . $_SERVER['HTTP_HOST'] . str_replace(basename($_SERVER['SCRIPT_NAME']), '', $_SERVER['SCRIPT_NAME']), '/');
$GLOBALS['bloginfo']['admin_email'] = 'chris@gearside.com';

//Control how scripts are loaded, and force clear cache for debugging
if ( array_key_exists('debug', $_GET) ) {
	$GLOBALS["debug"] = true;
	$GLOBALS["defer"] = '';
	$GLOBALS["async"] = '';
	$GLOBALS["gumby_debug"] = 'gumby-debug';
	header("Expires: Fri, 28 Mar 1986 02:40:00 GMT");
	header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");
	header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
	header("Cache-Control: post-check=0, pre-check=0", false);
	header("Pragma: no-cache");	
} else {
	$GLOBALS["debug"] = false;
	$GLOBALS["defer"] = 'defer';
	$GLOBALS["async"] = 'async';
	$GLOBALS["gumby_debug"] = 'defer';
}


/*========================== 
 Server-Side Google Analytics
 ===========================*/
set_error_handler('nebula_error_handler');

//Custom error handler
function nebula_error_handler($error_level, $error_message, $error_file, $error_line, $error_contest) {
    /*
    	@TODO: Parse errors cannot be caught with this function. In order to make it work, you must auto prepend a file using php.ini or .htaccess
		.htaccess method: php_value auto_prepend_file "./includes/shutdown_tracker.php" Note: this hasn't worked for me. Beyond that, no testing has been done.
		
		@TODO: Need to come up with a way to print errors without triggering "Headers already sent" warnings!
    */
    $error = array(
        'type' => 'Unknown Error',
        'definition' => 'Unknown Error Level',
        'level' => $error_level,
        'message' => $error_message,
        'file' => $error_file,
        'line' => $error_line,
        'contest' => $error_contest
    );
    
    switch ( $error_level ) {
	    case E_ERROR: //(1) Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted. [Not supported by set_error_handler()]
	    case E_CORE_ERROR: //(16) Fatal errors that occur during PHP's initial startup. This is like an E_ERROR, except it is generated by the core of PHP. [Not supported by set_error_handler()]
	    case E_COMPILE_ERROR: //(64) Fatal compile-time errors. This is like an E_ERROR, except it is generated by the Zend Scripting Engine. [Not supported by set_error_handler()]
	    case E_PARSE: //(4) Compile-time parse errors. Parse errors should only be generated by the parser. [Not supported by set_error_handler()]
	    	$error['type'] = 'Fatal Error';
	    	$error['definition'] = 'Fatal run-time errors that can not be recovered from. Execution of the script is halted. Includes E_Error [1], E_CORE_ERROR [16], E_COMPILE_ERROR [64], and E_PARSE [4].';
	        gaBuildData($error);
	        nebula_print_error($error);
	        exit(1);
	        break;
	    case E_USER_ERROR: //(256) User-generated error message. This is like an E_ERROR, except it is generated in PHP code by using the PHP function trigger_error().
	    case E_RECOVERABLE_ERROR: //(4096) Catchable fatal error. It indicates that a probably dangerous error occurred, but did not leave the Engine in an unstable state. If the error is not caught by a user defined handle, the application aborts as it was an E_ERROR.
	        $error['type'] = 'Error';
	        $error['definition'] = 'Indicates a probably dangerous error occurred, but did not leave the Engine in an unstable state. Includes E_USER_ERROR [256], and E_RECOVERABLE_ERROR [4096].';
	        gaBuildData($error);
	        nebula_print_error($error);
	        exit(1);
	        break;
	    case E_WARNING: //(2) Run-time warnings (non-fatal errors). Execution of the script is not halted.
	    case E_CORE_WARNING: //(32) Warnings (non-fatal errors) that occur during PHP's initial startup. This is like an E_WARNING, except it is generated by the core of PHP. [Not supported by set_error_handler()]
	    case E_COMPILE_WARNING: //(218) Compile-time warnings (non-fatal errors). This is like an E_WARNING, except it is generated by the Zend Scripting Engine. [Not supported by set_error_handler()]
	    case E_USER_WARNING: //(256) User-generated error message. This is like an E_ERROR, except it is generated in PHP code by using the PHP function trigger_error().
	        $error['type'] = 'Warning';
	        $error['definition'] = 'Run-time warnings (non-fatal errors). Execution of the script is not halted. Includes E_WARNING [2], E_CORE_WARNING [32], E_COMPILE_WARNING [218], and E_USER_WARNING [256].';
	        //gaBuildData($error); //Disabled GA event tracking of Warnings (Maybe we should send to a log file instead)
	        if ( $GLOBALS["debug"] ) {
	        	nebula_print_error($error);
	        }
	        break;
	    case E_NOTICE: //(8) Run-time notices. Indicate that the script encountered something that could indicate an error, but could also happen in the normal course of running a script.
	    case E_USER_NOTICE: //(1024) User-generated notice message. This is like an E_NOTICE, except it is generated in PHP code by using the PHP function trigger_error().
	    case E_DEPRECATED: //(8192) Run
	    case E_USER_DEPRECATED: //(16384) 
	        $error['type'] = 'Notice';
	        $error['definition'] = 'Run-time notices. Indicate that the script encountered something that could indicate an error, but could also happen in the normal course of running a script. Includes E_NOTICE [8], E_USER_NOTICE [1024], E_DEPRECATED [8192], and E_USER_DEPRECATED [16384].';
	        //gaBuildData($error); //Disabled GA event tracking of Notices (Maybe we should send to a log file instead)
	        if ( $GLOBALS["debug"] ) {
	        	nebula_print_error($error);
	        }
	        break;
		case E_STRICT: //(2048) Enable to have PHP suggest changes to your code which will ensure the best interoperability and forward compatibility of your code.
			$error['type'] = 'Strict';
			$error['definition'] = 'Suggested changes which will ensure the best interoperability and forward compatibility. Includes E_STRICT [2048].';
	        //gaBuildData($error); //Disabled GA event tracking of Notices (Maybe we should send to a log file instead)
	        if ( $GLOBALS["debug"] ) {
	        	nebula_print_error($error);
	        }
	        break;
	    default:
	        nebula_print_error($error);
	        gaBuildData($error);
	        break;
    }
	
    return true; //Don't execute PHP internal error handler
}

function nebula_print_error($error) {
	echo '<p class="nebula-php-error ' . strtolower(str_replace(' ', '-', $error['type'])) . '"><small title="' . $error['definition'] . '">[' . $error['level'] . ']</small> <strong title="' . $error['definition'] . '">' . $error['type'] . '</strong>: ' . $error['message'] . ' in <strong>' . $error['file'] . '</strong> on <strong>line ' . $error['line'] . '</strong>.</p>';
}

//Construct the data payload
function gaBuildData($error) {
	$v = 1; //Version
	$cid = gaParseCookie(); //Anonymous Client ID
	
	//Send event
	$data = array(
		'v' => $v,
		'tid' => $GLOBALS['ga'],
		'cid' => $cid,
		't' => 'event',
		'ec' => 'Error', //Category (Required)
		'ea' => 'PHP ' . $error['type'] . ' [' . $error['level'] . ']', //Action (Required)
		'el' => $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line'] //Label
	);
	gaSendData($data);
	
	//Send Exception hit
	$data = array(
		'v' => $v,
		'tid' => $GLOBALS['ga'],
		'cid' => $cid,
		't' => 'exception',
		'exd' => 'PHP ' . $error['type'] . ' [' . $error['level'] . ']', //Exception Description
		'exf' => 0 //Fatal Exception? (Boolean) //@TODO: Pull this data from the $error array (if 'type' contains 'fatal'). Doesn't matter until the handler supports fatal errors.
	);
	gaSendData($data);
}

//Handle the parsing of the _ga cookie or setting it to a unique identifier
function gaParseCookie() {
	if (isset($_COOKIE['_ga'])) {
		list($version,$domainDepth, $cid1, $cid2) = explode('.', $_COOKIE["_ga"], 4);
		$contents = array('version' => $version, 'domainDepth' => $domainDepth, 'cid' => $cid1 . '.' . $cid2);
		$cid = $contents['cid'];
	} else {
		$cid = gaGenerateUUID();
	}
	return $cid;
}

//Generate UUID v4 function - needed to generate a CID when one isn't available
function gaGenerateUUID() {
	return sprintf( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
		mt_rand(0, 0xffff), mt_rand(0, 0xffff), //32 bits for "time_low"
		mt_rand(0, 0xffff), //16 bits for "time_mid"
		mt_rand(0, 0x0fff) | 0x4000, //16 bits for "time_hi_and_version", Four most significant bits holds version number 4
		mt_rand(0, 0x3fff) | 0x8000, //16 bits, 8 bits for "clk_seq_hi_res", 8 bits for "clk_seq_low", Two most significant bits holds zero and one for variant DCE1.1
		mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff) //48 bits for "node"
	);
}

//Send Data to Google Analytics
//https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide#event
function gaSendData($data) {
	$getString = 'https://ssl.google-analytics.com/collect';
	$getString .= '?payload_data&';
	$getString .= http_build_query($data);
	$result = wp_remote_get($getString);
	return $result;
}


function nebula_facebook_link() {
	echo '<p class="facebook-connect-con"><i class="fa fa-facebook-square"></i> <a class="facebook-connect" href="#">Connect with Facebook</a></p>';
}


/*==========================
 
 Custom Functions 
 
 ===========================*/

//Set server timezone to match Wordpress
date_default_timezone_set('America/New_York');


//Text limiter by words
function string_limit_words($string, $word_limit){
	$limited[0] = $string;
	$limited[1] = 0;
	$words = explode(' ', $string, ($word_limit + 1));
	if(count($words) > $word_limit){
		array_pop($words);
		$limited[0] = implode(' ', $words);
		$limited[1] = 1;
	}
	return $limited;
}


//Word limiter by characters
function word_limit_chars($string, $charlimit, $continue=false){
	// 1 = "Continue Reading", 2 = "Learn More"
	if(strlen(strip_tags($string, '<p><span><a>')) <= $charlimit){
		$newString = strip_tags($string, '<p><span><a>');
	} else{
		$newString = preg_replace('/\s+?(\S+)?$/', '', substr(strip_tags($string, '<p><span><a>'), 0, ($charlimit + 1)));
		if($continue == 1){
			$newString = $newString . '&hellip;' . ' <a class="continuereading" href="'. get_permalink() . '">' . __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'boilerplate' ) . '</a>';
		} elseif($continue == 2){
			$newString = $newString . '&hellip;' . ' <a class="continuereading" href="'. get_permalink() . '">' . __( 'Learn more &raquo;', 'boilerplate' ) . '</a>';
		} else{
			$newString = $newString . '&hellip;';
		}
	}
	return $newString;
}

//PHP-Mobile-Detect - https://github.com/serbanghita/Mobile-Detect/wiki/Code-examples
//Before running conditions using this, you must have $detect = new Mobile_Detect(); before the logic. In this case we are using the global variable $GLOBALS["mobile_detect"].
//Logic can fire from "$GLOBALS["mobile_detect"]->isMobile()" or "$GLOBALS["mobile_detect"]->isTablet()" or "$GLOBALS["mobile_detect"]->is('AndroidOS')".
require_once 'includes/Mobile_Detect.php';
$GLOBALS["mobile_detect"] = new Mobile_Detect();

function mobile_classes() {
	$mobile_classes = '';
	if ( $GLOBALS["mobile_detect"]->isMobile() ) {
		$mobile_classes .= '  mobile ';
	} else {
		$mobile_classes .= '  no-mobile ';
	}
	if ( $GLOBALS["mobile_detect"]->isTablet() ) {
		$mobile_classes .= '  tablet ';
	}
	if ( $GLOBALS["mobile_detect"]->isiOS() ) {
		$mobile_classes .= '  ios ';
	}
	if ( $GLOBALS["mobile_detect"]->isAndroidOS() ) {
		$mobile_classes .= '  androidos ';
	}
	echo $mobile_classes;
}


function vimeo_meta($videoID) {
	global $vimeo_meta;
	$xml = simplexml_load_string(file_get_contents("http://vimeo.com/api/v2/video/" . $videoID . ".xml")); //@TODO: Will this work on a secure server?
	$vimeo_meta['id'] = $videoID;
	$vimeo_meta['title'] = $xml->video->title;
	$vimeo_meta['safetitle'] = str_replace(" ", "-", $vimeo_meta['title']);
	$vimeo_meta['description'] = $xml->video->description;
	$vimeo_meta['upload_date'] = $xml->video->upload_date;
	$vimeo_meta['thumbnail'] = $xml->video->thumbnail_large;
	$vimeo_meta['url'] = $xml->video->url;
	$vimeo_meta['user'] = $xml->video->user_name;
	$vimeo_meta['seconds'] = strval($xml->video->duration);
	$vimeo_meta['duration'] = intval(gmdate("i", $vimeo_meta['seconds'])) . gmdate(":s", $vimeo_meta['seconds']);
	return $vimeo_meta;
}


function youtube_meta($videoID) {
	global $youtube_meta;
	$xml = simplexml_load_string(file_get_contents("http://gdata.youtube.com/feeds/api/videos/" . $videoID)); //@TODO: Will this work on a secure server?
	$youtube_meta['origin'] = baseDomain();
	$youtube_meta['id'] = $videoID;
	$youtube_meta['title'] = $xml->title;
	$youtube_meta['safetitle'] = str_replace(" ", "-", $youtube_meta['title']);
	$youtube_meta['content'] = $xml->content;
	$youtube_meta['href'] = $xml->link['href'];
	$youtube_meta['author'] = $xml->author->name;
	$temp = $xml->xpath('//yt:duration[@seconds]');
    $youtube_meta['seconds'] = strval($temp[0]->attributes()->seconds);	
	$youtube_meta['duration'] = intval(gmdate("i", $youtube_meta['seconds'])) . gmdate(":s", $youtube_meta['seconds']);
	return $youtube_meta;
}


function baseDomain($str='') {
	if ( $str == '' ) {
		$str = home_url();
	}
    $url = @parse_url( $str );
    if ( empty( $url['host'] ) ) return;
    $parts = explode( '.', $url['host'] );
    $slice = ( strlen( reset( array_slice( $parts, -2, 1 ) ) ) == 2 ) && ( count( $parts ) > 2 ) ? 3 : 2;
    $protocol = stripos($_SERVER['SERVER_PROTOCOL'],'https') === true ? 'https://' : 'http://';
    return $protocol . implode( '.', array_slice( $parts, ( 0 - $slice ), $slice ) );
}


//Traverse multidimensional arrays
function in_array_r($needle, $haystack, $strict = true) {
    foreach ($haystack as $item) {
        if (($strict ? $item === $needle : $item == $needle) || (is_array($item) && in_array_r($needle, $item, $strict))) {
            return true;
        }
    }
    return false;
}

//Recursive Glob
function glob_r($pattern, $flags = 0) {
	    $files = glob($pattern, $flags); 
	    foreach (glob(dirname($pattern) . '/*', GLOB_ONLYDIR|GLOB_NOSORT) as $dir) {
	        $files = array_merge($files, glob_r($dir . '/' . basename($pattern), $flags));
	    }
	    return $files;
	}
	
//Add up the filesizes of files in a directory (and it's sub-directories)
function foldersize($path) {
	$total_size = 0;
	$files = scandir($path);
	$cleanPath = rtrim($path, '/') . '/';
	foreach($files as $t) {
		if ($t<>"." && $t<>"..") {
			$currentFile = $cleanPath . $t;
			if (is_dir($currentFile)) {
				$size = foldersize($currentFile);
				$total_size += $size;
			} else {
				$size = filesize($currentFile);
				$total_size += $size;
			}
		}   
	}
	return $total_size;
}
	

//Create tel: link if on mobile, otherwise return unlinked, human-readable number
function nebula_tel_link($phone, $postd=''){
	if ( $GLOBALS["mobile_detect"]->isMobile() ) {
		if ( $postd ) {
			$search = array('#', 'p', 'w');
			$replace   = array('%23', ',', ';');
			$postd = str_replace($search, $replace, $postd);
			if ( strpos($postd, ',') === false || strpos($postd, ';') === false ) {
				$postd = ',' . $postd;
			}
		}
		return '<a class="nebula-tel-link" href="tel:' . nebula_phone_format($phone, 'tel') . $postd . '">' . nebula_phone_format($phone, 'human') . '</a>';
	} else {
		return nebula_phone_format($phone, 'human');
	}
}

//Create sms: link if on mobile, otherwise return unlinked, human-readable number
function nebula_sms_link($phone, $message=''){
	if ( $GLOBALS["mobile_detect"]->isMobile() ) {
		$sep = ( $GLOBALS["mobile_detect"]->isiOS() ) ? '?' : ';';
		//@TODO: Encode $message string here...?
		return '<a class="nebula-sms-link" href="sms:' . nebula_phone_format($phone, 'tel') . $sep . 'body=' . $message . '">' . nebula_phone_format($phone, 'human') . '</a>';
	} else {
		return nebula_phone_format($phone, 'human');
	}
}

//Convert phone numbers into ten digital dial-able or to human-readable
function nebula_phone_format($number, $format=''){
	
	if ( $format == 'human' && (strpos($number, ')') == 4 || strpos($number, ')') == 6) ) {
		//Format is already human-readable
		return $number;
	} elseif ( $format == 'tel' && (strpos($number, '+1') == 0 && strlen($number) == 12) ) {
		//Format is already dialable
		return $number;
	}
	
	if ( (strpos($number, '+1') == 0 && strlen($number) == 12) || (strpos($number, '1') == 0 && strlen($number) == 11) || strlen($number) == 10 && $format != 'tel' ) {
		//Convert from dialable to human
		if ( strpos($number, '1') == 0 && strlen($number) == 11 ) {
			//13154786700
			$number = '(' . substr($number, 1, 3) . ') ' . substr($number, 4, 3) . '-' . substr($number, 7);
		} elseif ( strlen($number) == 10 ) {
			//3154786700
			$number = '(' . substr($number, 0, 3) . ') ' . substr($number, 3, 3) . '-' . substr($number, 6);
		} elseif ( strpos($number, '+1') == 0 && strlen($number) == 12 ) {
			//+13154786700
			$number = '(' . substr($number, 2, 3) . ') ' . substr($number, 5, 3) . '-' . substr($number, 8);
		} else {
			return 'Error: Unknown format.';
		}
		//@TODO: Maybe any numbers after "," "p" ";" or "w" could be added to the human-readable in brackets, like: (315) 555-1346 [323]
		//To do the above, set a remainder variable from above and add it to the return (if it exists). Maybe even add them to a span with a class so they can be hidden if undesired?
		return $number;
	} else {
		if ( strlen($number) < 7 ) {
			return 'Error: Too few digits.';
		} elseif ( strlen($number) < 10 ) {
			return 'Error: Too few digits (area code is required).';
		}
		//Convert from human to dialable
		if ( strpos($number, '1') != '0' ) {
			$number = '1 ' . $number;
		}
		
		if ( strpos($number,'x') !== false ) {
			$postd = ';p' . substr($number, strpos($number, "x") + 1);
		} else {
			$postd = '';
		}
		$number = str_replace(array(' ', '-', '(', ')', '.', 'x'), '', $number);
		$number = substr($number, 0, 11);
		return '+' . $number . $postd;
	}
}


//Automatically convert HEX colors to RGB.
function hex2rgb( $colour ) {
	if ( $colour[0] == '#' ) {
		$colour = substr( $colour, 1 );
	}
	if ( strlen( $colour ) == 6 ) {
		list( $r, $g, $b ) = array( $colour[0] . $colour[1], $colour[2] . $colour[3], $colour[4] . $colour[5] );
	} elseif ( strlen( $colour ) == 3 ) {
		list( $r, $g, $b ) = array( $colour[0] . $colour[0], $colour[1] . $colour[1], $colour[2] . $colour[2] );
	} else {
		return false;
	}
	$r = hexdec( $r );
	$g = hexdec( $g );
	$b = hexdec( $b );
	return array( 'red' => $r, 'green' => $g, 'blue' => $b );
}

//Close functions.php. Do not add anything after this closing tag!! ?>
